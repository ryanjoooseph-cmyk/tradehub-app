name: auto-update-and-merge
on:
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review, labeled]

concurrency:
  group: pr-${{ github.event.pull_request.number }}-${{ github.workflow }}
  cancel-in-progress: true

jobs:
  update-and-merge:
    if: startsWith(github.head_ref, 'agent-')
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: write
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const pr = context.payload.pull_request;
            const number = pr.number;

            // Ensure not draft
            if (pr.draft) {
              await github.rest.pulls.update({ owner, repo, pull_number: number, draft: false });
            }

            // Ensure automerge label
            const labels = pr.labels.map(l => l.name);
            if (!labels.includes('automerge')) {
              await github.rest.issues.addLabels({ owner, repo, issue_number: number, labels: ['automerge'] });
            }

            // Refresh PR data
            const full = await github.rest.pulls.get({ owner, repo, pull_number: number });
            const state = full.data.mergeable_state;

            // Update branch if needed (best-effort)
            if (['dirty', 'behind', 'unstable', 'unknown'].includes(state)) {
              try { await github.rest.pulls.updateBranch({ owner, repo, pull_number: number }); } catch (e) {}
            }

            // Enable automerge (best-effort)
            try {
              await github.graphql(
                'mutation($pr:ID!){ enablePullRequestAutoMerge(input:{pullRequestId:$pr, mergeMethod:SQUASH}){ clientMutationId } }',
                { pr: full.data.node_id }
              );
            } catch (e) {}
