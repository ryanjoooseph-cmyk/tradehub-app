name: auto-update-and-merge
on:
  workflow_dispatch:
  schedule:
    - cron: '*/5 * * * *'
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review, labeled]
permissions:
  contents: write
  pull-requests: write
jobs:
  update-and-merge:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const prs = await github.paginate(github.rest.pulls.list, {owner, repo, state: 'open', per_page: 100});
            for (const pr of prs) {
              if (!pr.head.ref.startsWith('agent-')) continue;
              const number = pr.number;
              if (pr.draft) {
                await github.rest.pulls.update({owner, repo, pull_number: number, draft: false});
              }
              const labels = pr.labels.map(l => l.name);
              if (!labels.includes('automerge')) {
                await github.rest.issues.addLabels({owner, repo, issue_number: number, labels: ['automerge']});
              }
              const full = await github.rest.pulls.get({owner, repo, pull_number: number});
              const state = full.data.mergeable_state;
              if (state === 'dirty' || state === 'behind' || state === 'unstable' || state === 'unknown') {
                try { await github.rest.pulls.updateBranch({owner, repo, pull_number: number}); } catch(e) {}
              }
              const prNodeId = full.data.node_id;
              try {
                await github.graphql(
                  'mutation($pr:ID!){ enablePullRequestAutoMerge(input:{pullRequestId:$pr, mergeMethod:SQUASH}){ clientMutationId } }',
                  { pr: prNodeId }
                );
              } catch(e) {}
            }
