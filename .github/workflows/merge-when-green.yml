name: merge-when-green

on:
  pull_request_target:
    types: [opened, reopened, synchronize, labeled]

permissions:
  contents: write
  pull-requests: write

jobs:
  automerge:
    name: automerge
    # only run if the PR has the "automerge" label
    if: contains(join(fromJson(toJson(github.event.pull_request.labels)).*.name, ','), 'automerge')
    runs-on: ubuntu-latest
    steps:
      - name: Wait for guard to pass
        uses: lewagon/wait-on-check-action@v1.3.4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          check-name: 'safe-automerge / guard'
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 10
          allowed-conclusions: success

      - name: Squash-merge the PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const { owner, repo } = context.repo;

            // refresh mergeability
            const { data } = await github.pulls.get({ owner, repo, pull_number: pr.number });

            if (data.mergeable_state === 'dirty') {
              core.setFailed('PR has conflicts; cannot merge.');
              return;
            }

            await github.pulls.merge({
              owner, repo,
              pull_number: pr.number,
              merge_method: 'squash'
            });

      - name: Delete head branch (same-repo only)
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const { owner, repo } = context.repo;
            if (pr.head.repo.full_name === `${owner}/${repo}`) {
              const ref = `heads/${pr.head.ref}`;
              try { await github.git.deleteRef({ owner, repo, ref }); } catch (e) {}
            }
