name: merge-when-green
on:
  pull_request:
    types: [opened, reopened, synchronize, labeled, ready_for_review]
permissions:
  contents: write
  pull-requests: write
  checks: read
  statuses: read

jobs:
  merge:
    if: >
      github.event.pull_request.draft == false &&
      contains(github.event.pull_request.labels.*.name, 'automerge') &&
      !contains(github.event.pull_request.labels.*.name, 'blocked')
    runs-on: ubuntu-latest
    steps:
      - name: Auto-approve (satisfy “1 approval” rules)
        uses: peter-evans/approve-pull-request@v3
        with:
          pull-request-number: ${{ github.event.pull_request.number }}
          approval-message: "Auto-approval for automerge-labeled agent PR."
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update branch if behind main
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            if (pr.mergeable_state === 'behind') {
              try {
                await github.pulls.updateBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number
                });
              } catch (e) {
                core.warning(`updateBranch failed: ${e.message}`);
              }
            }

      - name: Wait for checks to succeed
        uses: lewagon/wait-on-check-action@v1.3.4
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          check-name-regex: '.*'
          ref: ${{ github.event.pull_request.head.sha }}
          allowed-conclusions: success

      - name: Merge (squash)
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            await github.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              merge_method: 'squash'
            });
