name: safe-automerge

on:
  pull_request_target:
    types: [opened, reopened, synchronize, labeled, unlabeled, edited, ready_for_review]
  schedule:
    - cron: '*/10 * * * *'   # periodic sweep to drain backlog

permissions:
  contents: write
  pull-requests: write
  statuses: write

env:
  # Change to ALL if you want *everything* with the automerge label to merge automatically.
  AUTOMERGE_MODE: SAFE
  AUTOMERGE_LABEL: automerge
  REQUIRED_STATUS_CONTEXT: safe-automerge

jobs:
  merge-or-skip:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    concurrency:
      group: automerge-${{ github.event.pull_request.number || 'sweep' }}
      cancel-in-progress: false
    steps:
      - name: Decide & merge (single PR or sweep)
        uses: actions/github-script@v7
        with:
          script: |
            const mode   = process.env.AUTOMERGE_MODE || 'SAFE';
            const label  = process.env.AUTOMERGE_LABEL || 'automerge';
            const ctx    = context;
            const owner  = ctx.repo.owner;
            const repo   = ctx.repo.repo;

            async function hasLabel(number) {
              const { data } = await github.rest.issues.listLabelsOnIssue({ owner, repo, issue_number: number });
              return data.some(l => l.name === label);
            }

            async function filesAreDocsOnly(number) {
              const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number: number, per_page: 100 });
              // SAFE mode: only allow agents/<any>/plan.md changes
              return files.every(f => /^agents\/[^/]+\/plan\.md$/.test(f.filename));
            }

            async function publishStatus(sha, ok) {
              await github.rest.repos.createCommitStatus({
                owner, repo, sha,
                context: process.env.REQUIRED_STATUS_CONTEXT,
                state: ok ? 'success' : 'failure',
                description: ok ? 'eligible' : 'not eligible',
                target_url: `https://github.com/${owner}/${repo}`
              });
            }

            async function tryMerge(number) {
              const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: number });
              const labeled = await hasLabel(number);
              let eligible = labeled;

              if (eligible && (mode || 'SAFE').toUpperCase() === 'SAFE') {
                eligible = await filesAreDocsOnly(number);
              }

              // Publish the single required status either way
              await publishStatus(pr.head.sha, eligible);

              if (!eligible) return false;

              try {
                await github.rest.pulls.merge({
                  owner, repo, pull_number: number, merge_method: 'squash'
                });
                return true;
              } catch (e) {
                // If mergeable state wasnâ€™t ready yet, we just exit and the scheduled sweep will retry.
                core.warning(`Merge attempt failed for #${number}: ${e.message}`);
                return false;
              }
            }

            if (ctx.eventName === 'pull_request_target' && ctx.payload.pull_request) {
              await tryMerge(ctx.payload.pull_request.number);
            } else {
              // Scheduled sweep: process all open PRs with the label
              const prs = await github.paginate(github.rest.pulls.list, { owner, repo, state: 'open', per_page: 100 });
              for (const pr of prs) {
                if (await hasLabel(pr.number)) {
                  await tryMerge(pr.number);
                }
              }
            }
