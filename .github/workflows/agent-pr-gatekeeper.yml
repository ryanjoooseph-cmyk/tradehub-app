name: Agent - PR Gatekeeper

on:
  pull_request:
    types: [opened, synchronize, reopened]
  issue_comment:
    types: [created]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  gatekeeper:
    runs-on: ubuntu-latest
    steps:
      - name: PR Gatekeeper
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            (async () => {
              try {
                const owner = context.repo.owner;
                const repo = context.repo.repo;
                
                // Early exit for issue_comment events
                if (context.eventName === 'issue_comment') {
                  const issue = context.payload.issue;
                  const comment = context.payload.comment;
                  
                  // Only proceed if this is a PR
                  if (!issue.pull_request) {
                    console.log('Comment on non-PR issue, skipping');
                    return;
                  }
                  
                  // Only proceed if comment is from an agent
                  const commentBody = comment.body || '';
                  const isAgentComment = commentBody.includes('<!-- AGENT_RELEASE_MANAGER -->') || 
                                        commentBody.includes('<!-- AGENT_REGRESSION_GUARD -->');
                  
                  if (!isAgentComment) {
                    console.log('Comment is not from Release Manager or Regression Guard, skipping');
                    return;
                  }
                  
                  console.log('Agent comment detected, proceeding with gatekeeper logic');
                }
                
                // Determine PR number and head SHA for both event types
                let prNumber;
                let sha;
                
                if (context.eventName === 'issue_comment') {
                  // For issue_comment, fetch PR details
                  prNumber = context.payload.issue.number;
                  console.log(`Fetching PR #${prNumber} details from issue_comment event`);
                  
                  const { data: prData } = await github.rest.pulls.get({
                    owner,
                    repo,
                    pull_number: prNumber,
                  });
                  
                  sha = prData.head.sha;
                } else {
                  // For pull_request event, use payload directly
                  prNumber = context.payload.pull_request.number;
                  sha = context.payload.pull_request.head.sha;
                }
                
                console.log(`Processing PR #${prNumber}, SHA: ${sha}`);

                const RM_MARKER = '<!-- AGENT_RELEASE_MANAGER -->';
                const RG_MARKER = '<!-- AGENT_REGRESSION_GUARD -->';
                const GK_MARKER = '<!-- AGENT_PR_GATEKEEPER -->';

                const riskRank = { LOW: 1, MEDIUM: 2, HIGH: 3 };

                function extractRisk(body) {
                  if (!body) return null;
                  const jsonMatch = body.match(/"risk"\s*:\s*"(LOW|MEDIUM|HIGH)"/i);
                  if (jsonMatch) return jsonMatch[1].toUpperCase();
                  // Allow any characters (including emojis) between "risk" and risk level
                  const nearRisk = body.match(/risk[\s\S]{0,80}?(LOW|MEDIUM|HIGH)/i);
                  if (nearRisk) return nearRisk[1].toUpperCase();
                  if (body.includes('ðŸ”´')) return 'HIGH';
                  if (body.includes('ðŸŸ¡')) return 'MEDIUM';
                  if (body.includes('ðŸŸ¢')) return 'LOW';
                  if (/\bHIGH\b/i.test(body)) return 'HIGH';
                  if (/\bMEDIUM\b/i.test(body)) return 'MEDIUM';
                  if (/\bLOW\b/i.test(body)) return 'LOW';
                  return null;
                }

                async function safeAddLabels(labels) {
                  if (!labels || labels.length === 0) return;
                  await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels });
                }

                async function safeRemoveLabel(name) {
                  try {
                    await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name });
                  } catch (e) {}
                }

                // Paginate comments (don't assume 100 is enough)
                let comments = [];
                let page = 1;
                let hasMore = true;
                
                while (hasMore && page <= 20) {
                  const { data: pageComments } = await github.rest.issues.listComments({
                    owner,
                    repo,
                    issue_number: prNumber,
                    per_page: 100,
                    page,
                  });
                  
                  comments = comments.concat(pageComments);
                  hasMore = pageComments.length === 100;
                  page++;
                }
                
                console.log(`Loaded ${comments.length} comments across ${page - 1} page(s)`);

                function isGatekeeperComment(body) {
                  return typeof body === 'string' && body.includes(GK_MARKER);
                }

                let rmRisk = null;
                let rgRisk = null;

                for (let i = comments.length - 1; i >= 0; i--) {
                  const body = comments[i]?.body || '';
                  if (isGatekeeperComment(body)) continue;
                  if (body.includes(RM_MARKER)) { rmRisk = extractRisk(body); break; }
                }

                for (let i = comments.length - 1; i >= 0; i--) {
                  const body = comments[i]?.body || '';
                  if (isGatekeeperComment(body)) continue;
                  if (body.includes(RG_MARKER)) { rgRisk = extractRisk(body); break; }
                }

                const RM = (rmRisk || 'MEDIUM').toUpperCase();
                const RG = (rgRisk || 'MEDIUM').toUpperCase();
                const finalRisk = (riskRank[RM] >= riskRank[RG]) ? RM : RG;

                const { data: checkRuns } = await github.rest.checks.listForRef({
                  owner,
                  repo,
                  ref: sha,
                  per_page: 100,
                });

                const badConclusions = new Set(['failure', 'cancelled', 'timed_out', 'action_required']);
                const failing = (checkRuns.check_runs || [])
                  .filter(cr => cr.conclusion && badConclusions.has(cr.conclusion))
                  .map(cr => cr.name);

                const hasFailingChecks = failing.length > 0;
                const shouldBlock = hasFailingChecks || finalRisk === 'HIGH';

                if (finalRisk === 'HIGH') {
                  await safeAddLabels(['needs-review', 'risk-high']);
                  await safeRemoveLabel('risk-med');
                  await safeRemoveLabel('risk-low');
                } else if (finalRisk === 'MEDIUM') {
                  await safeAddLabels(['risk-med']);
                  await safeRemoveLabel('needs-review');
                  await safeRemoveLabel('risk-high');
                  await safeRemoveLabel('risk-low');
                } else {
                  await safeAddLabels(['risk-low']);
                  await safeRemoveLabel('needs-review');
                  await safeRemoveLabel('risk-high');
                  await safeRemoveLabel('risk-med');
                }

                let autoMergeDisabled = false;
                if (shouldBlock) {
                  const q = await github.graphql(
                    `query($owner:String!, $repo:String!, $number:Int!) {
                      repository(owner:$owner, name:$repo) {
                        pullRequest(number:$number) {
                          id
                          autoMergeRequest { enabledAt }
                        }
                      }
                    }`,
                    { owner, repo, number: prNumber }
                  );

                  const prId = q?.repository?.pullRequest?.id;
                  const autoMergeEnabled = !!q?.repository?.pullRequest?.autoMergeRequest;

                  if (prId && autoMergeEnabled) {
                    await github.graphql(
                      `mutation($pullRequestId: ID!) {
                        disablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId }) {
                          pullRequest { number }
                        }
                      }`,
                      { pullRequestId: prId }
                    );
                    autoMergeDisabled = true;
                  }
                }

                const emoji = finalRisk === 'HIGH' ? 'ðŸ”´' : (finalRisk === 'MEDIUM' ? 'ðŸŸ¡' : 'ðŸŸ¢');
                const statusLine = shouldBlock ? '**Status:** â›” BLOCKED' : '**Status:** âœ… CLEAR';

                let out = `${GK_MARKER}\n## ðŸš¦ PR Gatekeeper\n\n`;
                out += `${statusLine}\n`;
                out += `**Risk Level:** ${emoji} ${finalRisk}\n`;
                out += `**Checks:** ${hasFailingChecks ? 'âŒ FAILING' : 'âœ… PASSING'}\n\n`;

                if (hasFailingChecks) {
                  out += `### âŒ Failing Checks\n`;
                  for (const name of failing) out += `- ${name}\n`;
                  out += `\n`;
                }

                out += `### âœ… Verification Checklist\n`;
                out += `- Confirm no console errors\n`;
                out += `- Smoke test touched flows\n`;
                out += `- pnpm lint / typecheck / build are green\n\n`;
                out += autoMergeDisabled
                  ? `---\nAuto-merge was disabled because this PR is BLOCKED or HIGH risk.\n`
                  : `---\nAuto-merge unchanged.\n`;

                const existing = comments.find(c => (c.body || '').includes(GK_MARKER));
                if (existing) {
                  await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body: out });
                } else {
                  await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: out });
                }

              } catch (e) {
                console.error('Gatekeeper failed (non-blocking):', e);
              }
            })();
