name: Agent - PR Gatekeeper

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  gatekeeper:
    runs-on: ubuntu-latest
    steps:
      - name: PR Gatekeeper
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const pr = context.payload.pull_request;
              const prNumber = pr.number;
              const headSha = pr.head.sha;
              const owner = context.repo.owner;
              const repo = context.repo.repo;
              
              console.log(`Processing PR #${prNumber} (${headSha})`);
              
              function extractRisk(body) {
                if (!body) return null;

                // Prefer explicit JSON-style risk fields
                const jsonMatch = body.match(/"risk"\s*:\s*"(LOW|MEDIUM|HIGH)"/i);
                if (jsonMatch) return jsonMatch[1].toUpperCase();

                // Prefer lines that mention risk
                const nearRisk = body.match(/risk[^A-Z]*(LOW|MEDIUM|HIGH)/i);
                if (nearRisk) return nearRisk[1].toUpperCase();

                // Emoji fallback
                if (body.includes('ðŸ”´')) return 'HIGH';
                if (body.includes('ðŸŸ¡')) return 'MEDIUM';
                if (body.includes('ðŸŸ¢')) return 'LOW';

                // Last resort: any standalone tokens
                if (/\bHIGH\b/i.test(body)) return 'HIGH';
                if (/\bMEDIUM\b/i.test(body)) return 'MEDIUM';
                if (/\bLOW\b/i.test(body)) return 'LOW';

                return null;
              }
              
              // Step 1: Read PR comments and find latest agent comments
              const { data: comments } = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: prNumber,
              });
              
              let releaseManagerRisk = null;
              let regressionGuardRisk = null;
              
              // Find latest Release Manager comment
              for (let i = comments.length - 1; i >= 0; i--) {
                if (comments[i].body && comments[i].body.includes('<!-- AGENT_RELEASE_MANAGER -->')) {
                  const r = extractRisk(comments[i].body);
                  if (r) {
                    releaseManagerRisk = r;
                    console.log(`Found Release Manager risk: ${releaseManagerRisk}`);
                    break;
                  }
                }
              }
              
              // Find latest Regression Guard comment
              for (let i = comments.length - 1; i >= 0; i--) {
                if (comments[i].body && comments[i].body.includes('<!-- AGENT_REGRESSION_GUARD -->')) {
                  const r = extractRisk(comments[i].body);
                  if (r) {
                    regressionGuardRisk = r;
                    console.log(`Found Regression Guard risk: ${regressionGuardRisk}`);
                    break;
                  }
                }
              }
              
              // Determine highest risk (default to MEDIUM if not found)
              const riskLevels = { 'LOW': 1, 'MEDIUM': 2, 'HIGH': 3 };
              const risks = [releaseManagerRisk, regressionGuardRisk].filter(Boolean);
              let overallRisk = 'MEDIUM';
              
              if (risks.length > 0) {
                overallRisk = risks.reduce((highest, current) => {
                  return riskLevels[current] > riskLevels[highest] ? current : highest;
                });
              }
              
              console.log(`Overall risk: ${overallRisk}`);
              
              // Step 2: Check for failing checks
              const { data: checkRuns } = await github.rest.checks.listForRef({
                owner,
                repo,
                ref: headSha,
              });
              
              const failingChecks = checkRuns.check_runs.filter(run => 
                ['failure', 'cancelled', 'timed_out', 'action_required'].includes(run.conclusion)
              );
              
              const hasFailingChecks = failingChecks.length > 0;
              const shouldBlock = hasFailingChecks || overallRisk === 'HIGH';
              
              console.log(`Failing checks: ${failingChecks.length}, Should block: ${shouldBlock}`);
              
              // Step 3: Determine labels to add/remove
              let labelsToAdd = [];
              let labelsToRemove = [];
              
              if (shouldBlock) {
                labelsToAdd = ['needs-review', 'risk-high'];
                labelsToRemove = ['risk-med', 'risk-low'];
              } else if (overallRisk === 'MEDIUM') {
                labelsToAdd = ['risk-med'];
                labelsToRemove = ['needs-review', 'risk-high', 'risk-low'];
              } else {
                labelsToAdd = ['risk-low'];
                labelsToRemove = ['needs-review', 'risk-high', 'risk-med'];
              }
              
              // Get current labels
              const currentLabels = pr.labels.map(l => l.name);
              
              // Add labels that don't exist
              for (const label of labelsToAdd) {
                if (!currentLabels.includes(label)) {
                  console.log(`Adding label: ${label}`);
                  await github.rest.issues.addLabels({
                    owner,
                    repo,
                    issue_number: prNumber,
                    labels: [label]
                  });
                }
              }
              
              // Remove labels that exist
              for (const label of labelsToRemove) {
                if (currentLabels.includes(label)) {
                  console.log(`Removing label: ${label}`);
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: prNumber,
                    name: label
                  }).catch(err => console.log(`Label ${label} not found or already removed`));
                }
              }
              
              // Step 4: Disable auto-merge if blocking
              if (shouldBlock) {
                console.log('Checking and disabling auto-merge via GraphQL');

                const q = await github.graphql(
                  `query($owner:String!, $repo:String!, $number:Int!) {
                    repository(owner:$owner, name:$repo) {
                      pullRequest(number:$number) {
                        id
                        autoMergeRequest { enabledAt }
                      }
                    }
                  }`,
                  { owner, repo, number: prNumber }
                );

                const prId = q?.repository?.pullRequest?.id;
                const autoMergeEnabled = !!q?.repository?.pullRequest?.autoMergeRequest;

                if (prId && autoMergeEnabled) {
                  await github.graphql(
                    `mutation($pullRequestId: ID!) {
                      disablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId }) {
                        pullRequest { number }
                      }
                    }`,
                    { pullRequestId: prId }
                  );
                  console.log('Auto-merge disabled');
                } else {
                  console.log('Auto-merge not enabled or PR id missing; nothing to disable');
                }
              }
              
              // Step 5: Create or update gatekeeper comment
              const marker = '<!-- AGENT_PR_GATEKEEPER -->';
              let commentBody = `${marker}\n## ðŸš¦ PR Gatekeeper\n\n`;
              
              const riskEmoji = overallRisk === 'HIGH' ? 'ðŸ”´' : overallRisk === 'MEDIUM' ? 'ðŸŸ¡' : 'ðŸŸ¢';
              commentBody += `**Risk Level:** ${riskEmoji} ${overallRisk}\n\n`;
              
              if (hasFailingChecks) {
                commentBody += `### âŒ Failing Checks (${failingChecks.length})\n`;
                failingChecks.forEach(check => {
                  commentBody += `- ${check.name} (${check.conclusion})\n`;
                });
                commentBody += `\n`;
              }
              
              if (shouldBlock) {
                commentBody = commentBody.replace('## ðŸš¦ PR Gatekeeper\n\n', '## ðŸš¦ PR Gatekeeper\n\n**Status:** â›” BLOCKED\n\n');
                commentBody += `### âœ… Required Actions\n`;
                commentBody += `- [ ] All CI checks must pass\n`;
                if (overallRisk === 'HIGH') {
                  commentBody += `- [ ] High-risk changes reviewed by senior engineer\n`;
                  commentBody += `- [ ] Manual testing completed\n`;
                }
                if (hasFailingChecks) {
                  commentBody += `- [ ] Fix failing checks listed above\n`;
                }
                commentBody += `- [ ] All review comments addressed\n\n`;
                commentBody += `---\n*Auto-merge has been disabled. Manual approval required.*`;
              } else {
                commentBody = commentBody.replace('## ðŸš¦ PR Gatekeeper\n\n', '## ðŸš¦ PR Gatekeeper\n\n**Status:** âœ… CLEAR\n\n');
                commentBody += `### âœ… Recommended Actions\n`;
                commentBody += `- [ ] No failing checks\n`;
                commentBody += `- [ ] Core flow smoke tests passed\n\n`;
              }
              
              // Find existing gatekeeper comment
              const existingComment = comments.find(c => c.body && c.body.includes(marker));
              
              if (existingComment) {
                console.log(`Updating existing gatekeeper comment ${existingComment.id}`);
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: existingComment.id,
                  body: commentBody
                });
              } else {
                console.log('Creating new gatekeeper comment');
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: prNumber,
                  body: commentBody
                });
              }
              
              console.log('PR Gatekeeper complete');
              
            } catch (error) {
              console.error('PR Gatekeeper error:', error);
              // Never fail the workflow
            }
