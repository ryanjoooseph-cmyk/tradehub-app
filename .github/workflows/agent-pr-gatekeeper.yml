name: Agent - PR Gatekeeper

on:
  pull_request:
    types: [opened, synchronize, reopened]
  issue_comment:
    types: [created]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  gatekeeper:
    runs-on: ubuntu-latest
    steps:
      - name: PR Gatekeeper
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            (async () => {
              try {
                const owner = context.repo.owner;
                const repo = context.repo.repo;
                
                // Early exit for issue_comment events
                if (context.eventName === 'issue_comment') {
                  const issue = context.payload.issue;
                  const comment = context.payload.comment;
                  
                  // Only proceed if this is a PR
                  if (!issue.pull_request) {
                    console.log('Comment on non-PR issue, skipping');
                    return;
                  }
                  
                  // Only proceed if comment looks like an agent risk output (markers OR risk-level content)
                  const commentBody = comment.body || '';
                  const isAgentComment =
                    commentBody.includes('<!-- AGENT_RELEASE_MANAGER -->') ||
                    commentBody.includes('<!-- AGENT_REGRESSION_GUARD -->') ||
                    commentBody.includes('Risk Level:') ||
                    commentBody.includes('**Risk Level:**') ||
                    commentBody.includes('ðŸ”´') ||
                    commentBody.includes('ðŸŸ¡') ||
                    commentBody.includes('ðŸŸ¢');

                  if (!isAgentComment) {
                    console.log('Comment is not an agent risk signal, skipping');
                    return;
                  }
                  
                  console.log('Agent comment detected, proceeding with gatekeeper logic');
                }
                
                // Determine PR number and head SHA for both event types
                let prNumber;
                let sha;
                
                if (context.eventName === 'issue_comment') {
                  // For issue_comment, fetch PR details
                  prNumber = context.payload.issue.number;
                  console.log(`Fetching PR #${prNumber} details from issue_comment event`);
                  
                  const { data: prData } = await github.rest.pulls.get({
                    owner,
                    repo,
                    pull_number: prNumber,
                  });
                  
                  sha = prData.head.sha;
                } else {
                  // For pull_request event, use payload directly
                  prNumber = context.payload.pull_request.number;
                  sha = context.payload.pull_request.head.sha;
                }
                
                console.log(`Processing PR #${prNumber}, SHA: ${sha}`);

                const RM_MARKER = '<!-- AGENT_RELEASE_MANAGER -->';
                const RG_MARKER = '<!-- AGENT_REGRESSION_GUARD -->';
                const GK_MARKER = '<!-- AGENT_PR_GATEKEEPER -->';

                const riskRank = { LOW: 1, MEDIUM: 2, HIGH: 3 };

                function extractRisk(body) {
                  if (!body) return null;
                  const jsonMatch = body.match(/"risk"\s*:\s*"(LOW|MEDIUM|HIGH)"/i);
                  if (jsonMatch) return jsonMatch[1].toUpperCase();
                  // Allow any characters (including emojis) between "risk" and risk level
                  const nearRisk = body.match(/risk[\s\S]{0,80}?(LOW|MEDIUM|HIGH)/i);
                  if (nearRisk) return nearRisk[1].toUpperCase();
                  if (body.includes('ðŸ”´')) return 'HIGH';
                  if (body.includes('ðŸŸ¡')) return 'MEDIUM';
                  if (body.includes('ðŸŸ¢')) return 'LOW';
                  if (/\bHIGH\b/i.test(body)) return 'HIGH';
                  if (/\bMEDIUM\b/i.test(body)) return 'MEDIUM';
                  if (/\bLOW\b/i.test(body)) return 'LOW';
                  return null;
                }

                async function safeAddLabels(labels) {
                  if (!labels || labels.length === 0) return;
                  await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels });
                }

                async function safeRemoveLabel(name) {
                  try {
                    await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name });
                  } catch (e) {}
                }

                function isGatekeeperComment(body) {
                  return typeof body === 'string' && body.includes(GK_MARKER);
                }

                async function loadCommentsWithRetry(maxRetries = 5) {
                  for (let attempt = 0; attempt < maxRetries; attempt++) {
                    let allComments = [];
                    let page = 1;
                    let hasMore = true;
                    
                    while (hasMore && page <= 20) {
                      const { data: pageComments } = await github.rest.issues.listComments({
                        owner,
                        repo,
                        issue_number: prNumber,
                        per_page: 100,
                        page,
                      });
                      
                      allComments = allComments.concat(pageComments);
                      hasMore = pageComments.length === 100;
                      page++;
                    }
                    
                    console.log(`Attempt ${attempt + 1}: Loaded ${allComments.length} comments`);
                    
                    // Check if we found at least one agent marker
                    const hasRM = allComments.some(c => c.body && c.body.includes(RM_MARKER));
                    const hasRG = allComments.some(c => c.body && c.body.includes(RG_MARKER));
                    
                    if (hasRM || hasRG || attempt === maxRetries - 1) {
                      return allComments;
                    }
                    
                    // Wait 2s before retry (eventual consistency)
                    console.log('Agent markers not found yet, retrying in 2s...');
                    await new Promise(resolve => setTimeout(resolve, 2000));
                  }
                  
                  return [];
                }

                // Step 1: If triggered by issue_comment, extract risk from triggering comment
                let rmRisk = null;
                let rgRisk = null;
                
                if (context.eventName === 'issue_comment') {
                  const triggerBody = context.payload.comment.body || '';

                  console.log('Checking triggering comment for markers and risk...');
                  const triggerRisk = extractRisk(triggerBody);
                  console.log(`Triggering comment extracted risk: ${triggerRisk}`);

                  if (triggerBody.includes(RM_MARKER)) {
                    rmRisk = triggerRisk;
                    console.log(`âœ“ Triggering comment has RM_MARKER, risk: ${rmRisk}`);
                  }
                  if (triggerBody.includes(RG_MARKER)) {
                    rgRisk = triggerRisk;
                    console.log(`âœ“ Triggering comment has RG_MARKER, risk: ${rgRisk}`);
                  }

                  // If no markers but risk exists, treat it as agent risk signal and fill missing slot(s)
                  if (!triggerBody.includes(RM_MARKER) && !triggerBody.includes(RG_MARKER) && triggerRisk) {
                    if (rmRisk === null) {
                      rmRisk = triggerRisk;
                      console.log(`âœ“ Filled rmRisk from unmarked trigger risk: ${rmRisk}`);
                    } else if (rgRisk === null) {
                      rgRisk = triggerRisk;
                      console.log(`âœ“ Filled rgRisk from unmarked trigger risk: ${rgRisk}`);
                    }
                  }
                }

                // Step 2: Load comments (with retry) if we still need to find markers
                const needsRM = rmRisk === null;
                const needsRG = rgRisk === null;
                
                let comments = [];
                if (needsRM || needsRG) {
                  console.log(`Need to fetch comments (needsRM: ${needsRM}, needsRG: ${needsRG})`);
                  comments = await loadCommentsWithRetry(5);
                  
                  // Search paginated comments for missing risks
                  if (needsRM) {
                    for (let i = comments.length - 1; i >= 0; i--) {
                      const body = comments[i]?.body || '';
                      if (isGatekeeperComment(body)) continue;
                      if (body.includes(RM_MARKER)) {
                        rmRisk = extractRisk(body);
                        console.log(`âœ“ Found RM_MARKER in comments, risk: ${rmRisk}`);
                        break;
                      }
                    }
                  }
                  
                  if (needsRG) {
                    for (let i = comments.length - 1; i >= 0; i--) {
                      const body = comments[i]?.body || '';
                      if (isGatekeeperComment(body)) continue;
                      if (body.includes(RG_MARKER)) {
                        rgRisk = extractRisk(body);
                        console.log(`âœ“ Found RG_MARKER in comments, risk: ${rgRisk}`);
                        break;
                      }
                    }
                  }
                }

                // Step 3: Fallback - scan latest 30 comments for "Risk Level:" without markers
                if (rmRisk === null || rgRisk === null) {
                  console.log('Markers not found, scanning latest comments for "Risk Level:"...');
                  
                  if (comments.length === 0) {
                    comments = await loadCommentsWithRetry(1);
                  }
                  
                  const latest30 = comments.slice(-30).reverse();
                  
                  for (const comment of latest30) {
                    const body = comment.body || '';
                    if (isGatekeeperComment(body)) continue;
                    
                    if (body.includes('Risk Level:') || body.includes('**Risk Level:**') || body.includes('ðŸ”´') || body.includes('ðŸŸ¡') || body.includes('ðŸŸ¢')) {
                      const foundRisk = extractRisk(body);
                      if (foundRisk) {
                        console.log(`âœ“ Found risk via "Risk Level:" scan: ${foundRisk}`);
                        // Assign to whichever is still null
                        if (rmRisk === null) rmRisk = foundRisk;
                        else if (rgRisk === null) rgRisk = foundRisk;
                        
                        if (rmRisk !== null && rgRisk !== null) break;
                      }
                    }
                  }
                }

                // Final risk determination with conservative default
                const RM = rmRisk || 'MEDIUM';
                const RG = rgRisk || 'MEDIUM';
                let finalRisk = (riskRank[RM] >= riskRank[RG]) ? RM : RG;
                
                console.log(`Risk from agents: RM=${RM}, RG=${RG}, Combined=${finalRisk}`);

                // Step 4: Fetch changed files and apply critical-file override
                let changedFiles = [];
                let filePage = 1;
                let hasMoreFiles = true;
                
                while (hasMoreFiles && filePage <= 10) {
                  const { data: files } = await github.rest.pulls.listFiles({
                    owner,
                    repo,
                    pull_number: prNumber,
                    per_page: 100,
                    page: filePage,
                  });
                  
                  changedFiles = changedFiles.concat(files.map(f => f.filename));
                  hasMoreFiles = files.length === 100;
                  filePage++;
                }
                
                console.log(`Changed files: ${changedFiles.length} total`);
                
                // Define critical patterns
                const criticalPatterns = [
                  { type: 'exact', value: 'web/src/app/layout.tsx', reason: 'root layout' },
                  { type: 'exact', value: 'web/src/components/app/AppShell.tsx', reason: 'app shell' },
                  { type: 'startsWith', value: 'web/src/styles/', reason: 'global styles' },
                  { type: 'startsWith', value: '.github/workflows/', reason: 'CI workflows' },
                  { type: 'startsWith', value: 'web/src/app/api/agent/', reason: 'agent infrastructure' },
                  { type: 'includes', value: '/escrow', reason: 'escrow logic' },
                ];
                
                const criticalMatches = [];
                for (const file of changedFiles) {
                  for (const pattern of criticalPatterns) {
                    let matches = false;
                    if (pattern.type === 'exact') {
                      matches = file === pattern.value;
                    } else if (pattern.type === 'startsWith') {
                      matches = file.startsWith(pattern.value);
                    } else if (pattern.type === 'includes') {
                      matches = file.includes(pattern.value);
                    }
                    
                    if (matches) {
                      criticalMatches.push({ file, reason: pattern.reason });
                      break;
                    }
                  }
                }
                
                // Apply critical-file override
                let criticalOverride = false;
                if (criticalMatches.length > 0) {
                  console.log(`ðŸš¨ Critical files detected (${criticalMatches.length}):`);
                  criticalMatches.forEach(m => console.log(`  - ${m.file} (${m.reason})`));
                  
                  if (finalRisk !== 'HIGH') {
                    console.log(`âš ï¸  Overriding risk from ${finalRisk} to HIGH due to critical files`);
                    finalRisk = 'HIGH';
                    criticalOverride = true;
                  }
                } else {
                  console.log('No critical files detected');
                }
                
                console.log(`Final risk after override: ${finalRisk}`);

                const { data: checkRuns } = await github.rest.checks.listForRef({
                  owner,
                  repo,
                  ref: sha,
                  per_page: 100,
                });

                const badConclusions = new Set(['failure', 'cancelled', 'timed_out', 'action_required']);
                const failing = (checkRuns.check_runs || [])
                  .filter(cr => cr.conclusion && badConclusions.has(cr.conclusion))
                  .map(cr => cr.name);

                const hasFailingChecks = failing.length > 0;
                const shouldBlock = hasFailingChecks || finalRisk === 'HIGH';

                if (finalRisk === 'HIGH') {
                  await safeAddLabels(['needs-review', 'risk-high']);
                  await safeRemoveLabel('risk-med');
                  await safeRemoveLabel('risk-low');
                } else if (finalRisk === 'MEDIUM') {
                  await safeAddLabels(['risk-med']);
                  await safeRemoveLabel('needs-review');
                  await safeRemoveLabel('risk-high');
                  await safeRemoveLabel('risk-low');
                } else {
                  await safeAddLabels(['risk-low']);
                  await safeRemoveLabel('needs-review');
                  await safeRemoveLabel('risk-high');
                  await safeRemoveLabel('risk-med');
                }

                let autoMergeDisabled = false;
                if (shouldBlock) {
                  const q = await github.graphql(
                    `query($owner:String!, $repo:String!, $number:Int!) {
                      repository(owner:$owner, name:$repo) {
                        pullRequest(number:$number) {
                          id
                          autoMergeRequest { enabledAt }
                        }
                      }
                    }`,
                    { owner, repo, number: prNumber }
                  );

                  const prId = q?.repository?.pullRequest?.id;
                  const autoMergeEnabled = !!q?.repository?.pullRequest?.autoMergeRequest;

                  if (prId && autoMergeEnabled) {
                    await github.graphql(
                      `mutation($pullRequestId: ID!) {
                        disablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId }) {
                          pullRequest { number }
                        }
                      }`,
                      { pullRequestId: prId }
                    );
                    autoMergeDisabled = true;
                  }
                }

                const emoji = finalRisk === 'HIGH' ? 'ðŸ”´' : (finalRisk === 'MEDIUM' ? 'ðŸŸ¡' : 'ðŸŸ¢');
                const statusLine = shouldBlock ? '**Status:** â›” BLOCKED' : '**Status:** âœ… CLEAR';

                let out = `${GK_MARKER}\n## ðŸš¦ PR Gatekeeper\n\n`;
                out += `${statusLine}\n`;
                out += `**Risk Level:** ${emoji} ${finalRisk}\n`;
                out += `**Checks:** ${hasFailingChecks ? 'âŒ FAILING' : 'âœ… PASSING'}\n\n`;

                if (criticalOverride && criticalMatches.length > 0) {
                  out += `### ðŸš¨ Critical Files Changed\n`;
                  out += `Risk escalated to HIGH due to changes in critical files:\n`;
                  criticalMatches.forEach(m => out += `- \`${m.file}\` (${m.reason})\n`);
                  out += `\n`;
                }

                if (hasFailingChecks) {
                  out += `### âŒ Failing Checks\n`;
                  for (const name of failing) out += `- ${name}\n`;
                  out += `\n`;
                }

                out += `### âœ… Verification Checklist\n`;
                out += `- Confirm no console errors\n`;
                out += `- Smoke test touched flows\n`;
                out += `- pnpm lint / typecheck / build are green\n\n`;
                out += autoMergeDisabled
                  ? `---\nAuto-merge was disabled because this PR is BLOCKED or HIGH risk.\n`
                  : `---\nAuto-merge unchanged.\n`;

                if (comments.length === 0) {
                  comments = await loadCommentsWithRetry(1);
                }

                const existing = comments.find(c => (c.body || '').includes(GK_MARKER));
                if (existing) {
                  await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body: out });
                } else {
                  await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: out });
                }

              } catch (e) {
                console.error('Gatekeeper failed (non-blocking):', e);
              }
            })();
