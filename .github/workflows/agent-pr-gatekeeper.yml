name: Agent - PR Gatekeeper

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write

jobs:
  gatekeeper:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: Get changed files
        id: files
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          pr="${{ github.event.pull_request.number }}"
          files=$(gh api "repos/${{ github.repository }}/pulls/${pr}/files" --paginate --jq '.[].filename')
          echo "files<<EOF" >> "$GITHUB_OUTPUT"
          echo "$files" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Skip gatekeeper for workflow-only PRs
        run: |
          set -euo pipefail
          only_workflows="true"
          while IFS= read -r f; do
            [ -z "$f" ] && continue
            case "$f" in
              .github/workflows/*) ;;
              *) only_workflows="false" ;;
            esac
          done <<< "${{ steps.files.outputs.files }}"
          if [ "$only_workflows" = "true" ]; then
            echo "Workflow-only PR detected; gatekeeper passing."
            exit 0
          fi

      - name: PR Gatekeeper
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const owner = context.repo.owner;
              const repo = context.repo.repo;

              // For pull_request event, use payload directly
              const prNumber = context.payload.pull_request.number;
              const sha = context.payload.pull_request.head.sha;
              const prData = context.payload.pull_request;

              console.log(`Processing PR #${prNumber}, SHA: ${sha}`);

              // Early exit if PR is already merged
              if (prData && prData.merged === true) {
                console.log(`‚úÖ PR #${prNumber} is already merged, exiting successfully`);
                return;
              }

              // Fetch PR labels (used for explicit override)
              let prLabels = [];
              try {
                const { data: labels } = await github.rest.issues.listLabelsOnIssue({
                  owner,
                  repo,
                  issue_number: prNumber,
                  per_page: 100,
                });
                prLabels = (labels || []).map(l => (l && l.name ? String(l.name) : '')).filter(Boolean);
              } catch (err) {
                console.error('‚ö†Ô∏è Unable to load PR labels (continuing):', err);
                prLabels = [];
              }

              const OVERRIDE_LABEL = 'override-gatekeeper';
              const isOverride = prLabels.includes(OVERRIDE_LABEL);
              console.log(`PR labels: ${prLabels.join(', ') || '(none)'}`);
              console.log(`Override label present (${OVERRIDE_LABEL}): ${isOverride}`);

              const RM_MARKER = '<!-- AGENT_RELEASE_MANAGER -->';
              const RG_MARKER = '<!-- AGENT_REGRESSION_GUARD -->';
              const GK_MARKER = '<!-- AGENT_PR_GATEKEEPER -->';

              const riskRank = { LOW: 1, MEDIUM: 2, HIGH: 3 };

              function extractRisk(body) {
                if (!body) return null;
                const jsonMatch = body.match(/"risk"\s*:\s*"(LOW|MEDIUM|HIGH)"/i);
                if (jsonMatch) return jsonMatch[1].toUpperCase();
                const nearRisk = body.match(/risk[\s\S]{0,80}?(LOW|MEDIUM|HIGH)/i);
                if (nearRisk) return nearRisk[1].toUpperCase();
                if (body.includes('üî¥')) return 'HIGH';
                if (body.includes('üü°')) return 'MEDIUM';
                if (body.includes('üü¢')) return 'LOW';
                if (/\bHIGH\b/i.test(body)) return 'HIGH';
                if (/\bMEDIUM\b/i.test(body)) return 'MEDIUM';
                if (/\bLOW\b/i.test(body)) return 'LOW';
                return null;
              }

              async function safeAddLabels(labels) {
                if (!labels || labels.length === 0) return;
                try {
                  await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels });
                } catch (e) {
                  console.warn('‚ö†Ô∏è Unable to add labels:', e.message);
                }
              }

              async function safeRemoveLabel(name) {
                try {
                  await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name });
                } catch (e) {}
              }

              function isGatekeeperComment(body) {
                return typeof body === 'string' && body.includes(GK_MARKER);
              }

              async function loadComments() {
                let allComments = [];
                let page = 1;
                let hasMore = true;

                while (hasMore && page <= 20) {
                  const { data: pageComments } = await github.rest.issues.listComments({
                    owner,
                    repo,
                    issue_number: prNumber,
                    per_page: 100,
                    page,
                  });

                  allComments = allComments.concat(pageComments);
                  hasMore = pageComments.length === 100;
                  page++;
                }

                console.log(`Loaded ${allComments.length} comments`);
                return allComments;
              }

              // Load comments and search for agent risk markers
              let rmRisk = null;
              let rgRisk = null;
              const comments = await loadComments();

              for (let i = comments.length - 1; i >= 0; i--) {
                const body = comments[i]?.body || '';
                if (isGatekeeperComment(body)) continue;

                if (rmRisk === null && body.includes(RM_MARKER)) {
                  rmRisk = extractRisk(body);
                  console.log(`‚úì Found RM_MARKER, risk: ${rmRisk}`);
                }
                if (rgRisk === null && body.includes(RG_MARKER)) {
                  rgRisk = extractRisk(body);
                  console.log(`‚úì Found RG_MARKER, risk: ${rgRisk}`);
                }
                if (rmRisk !== null && rgRisk !== null) break;
              }

              // Fallback scan for risk level
              if (rmRisk === null || rgRisk === null) {
                const latest30 = comments.slice(-30).reverse();
                for (const comment of latest30) {
                  const body = comment.body || '';
                  if (isGatekeeperComment(body)) continue;

                  if (body.includes('Risk Level:') || body.includes('**Risk Level:**') ||
                      body.includes('üî¥') || body.includes('üü°') || body.includes('üü¢')) {
                    const foundRisk = extractRisk(body);
                    if (foundRisk) {
                      if (rmRisk === null) rmRisk = foundRisk;
                      else if (rgRisk === null) rgRisk = foundRisk;
                      if (rmRisk !== null && rgRisk !== null) break;
                    }
                  }
                }
              }

              // Final risk determination
              const RM = rmRisk || 'MEDIUM';
              const RG = rgRisk || 'MEDIUM';
              let finalRisk = (riskRank[RM] >= riskRank[RG]) ? RM : RG;

              console.log(`Risk from agents: RM=${RM}, RG=${RG}, Combined=${finalRisk}`);

              // Fetch changed files
              let changedFiles = [];
              let filePage = 1;
              let hasMoreFiles = true;

              while (hasMoreFiles && filePage <= 10) {
                const { data: files } = await github.rest.pulls.listFiles({
                  owner,
                  repo,
                  pull_number: prNumber,
                  per_page: 100,
                  page: filePage,
                });

                changedFiles = changedFiles.concat(files.map(f => f.filename));
                hasMoreFiles = files.length === 100;
                filePage++;
              }

              console.log(`Changed files: ${changedFiles.length} total`);

              // Check for docs-auto-sync.yml as the only workflow change
              const workflowFiles = changedFiles.filter(f => f.startsWith('.github/workflows/'));
              const isOnlyDocsSync =
                workflowFiles.length === 1 &&
                workflowFiles[0] === '.github/workflows/docs-auto-sync.yml';

              if (isOnlyDocsSync && finalRisk === 'HIGH') {
                finalRisk = 'MEDIUM';
                console.log('‚ö†Ô∏è Downgraded risk from HIGH to MEDIUM for docs-auto-sync.yml change');
              }

              // Define critical patterns
              const criticalPatterns = [
                { type: 'exact', value: 'web/src/app/layout.tsx', reason: 'root layout' },
                { type: 'exact', value: 'web/src/components/app/AppShell.tsx', reason: 'app shell' },
                { type: 'startsWith', value: 'web/src/styles/', reason: 'global styles' },
                { type: 'startsWith', value: '.github/workflows/', reason: 'CI workflows' },
                { type: 'startsWith', value: 'web/src/app/api/agent/', reason: 'agent infrastructure' },
                { type: 'includes', value: '/escrow', reason: 'escrow logic' },
              ];

              const criticalMatches = [];
              for (const file of changedFiles) {
                if (isOnlyDocsSync && file === '.github/workflows/docs-auto-sync.yml') continue;

                for (const pattern of criticalPatterns) {
                  let matches = false;
                  if (pattern.type === 'exact') matches = file === pattern.value;
                  else if (pattern.type === 'startsWith') matches = file.startsWith(pattern.value);
                  else if (pattern.type === 'includes') matches = file.includes(pattern.value);

                  if (matches) {
                    criticalMatches.push({ file, reason: pattern.reason });
                    break;
                  }
                }
              }

              // Apply critical-file override
              let criticalOverride = false;
              if (criticalMatches.length > 0) {
                console.log(`üö® Critical files detected (${criticalMatches.length}):`);
                criticalMatches.forEach(m => console.log(`  - ${m.file} (${m.reason})`));

                if (finalRisk !== 'HIGH') {
                  console.log(`‚ö†Ô∏è Overriding risk from ${finalRisk} to HIGH due to critical files`);
                  finalRisk = 'HIGH';
                  criticalOverride = true;
                }
              }

              console.log(`Final risk: ${finalRisk}`);

              // Check for failing checks
              let failing = [];
              let hasFailingChecks = false;

              try {
                const { data: checkRuns } = await github.rest.checks.listForRef({
                  owner,
                  repo,
                  ref: sha,
                  per_page: 100,
                });

                const REQUIRED_CHECKS = ['web-build', 'gatekeeper'];
                const badConclusions = new Set(['failure', 'cancelled', 'timed_out', 'action_required']);

                failing = (checkRuns.check_runs || [])
                  .filter(cr => {
                    if (!cr.conclusion || !badConclusions.has(cr.conclusion)) return false;
                    const checkName = cr.name || '';
                    return REQUIRED_CHECKS.some(req => checkName.includes(req));
                  })
                  .map(cr => cr.name);

                hasFailingChecks = failing.length > 0;

                if (hasFailingChecks) {
                  console.log(`‚ö†Ô∏è Required checks failing: ${failing.join(', ')}`);
                } else {
                  console.log('‚úÖ All required checks passing');
                }
              } catch (err) {
                console.error('‚ö†Ô∏è Unable to read check-runs:', err.message);
              }

              const isWorkflowOnlyChange = changedFiles.length > 0 &&
                changedFiles.every(f => f.startsWith('.github/workflows/'));

              const shouldBlock = hasFailingChecks || (finalRisk === 'HIGH' && !isWorkflowOnlyChange && !isOverride);

              // Update labels
              if (finalRisk === 'HIGH') {
                await safeAddLabels(['needs-review', 'risk-high']);
                await safeRemoveLabel('risk-med');
                await safeRemoveLabel('risk-low');
              } else if (finalRisk === 'MEDIUM') {
                await safeAddLabels(['risk-med']);
                await safeRemoveLabel('needs-review');
                await safeRemoveLabel('risk-high');
                await safeRemoveLabel('risk-low');
              } else {
                await safeAddLabels(['risk-low']);
                await safeRemoveLabel('needs-review');
                await safeRemoveLabel('risk-high');
                await safeRemoveLabel('risk-med');
              }

              // Try to disable auto-merge for HIGH risk
              let autoMergeDisabled = false;
              if (hasFailingChecks || (finalRisk === 'HIGH' && !isOverride)) {
                try {
                  const q = await github.graphql(
                    `query($owner:String!, $repo:String!, $number:Int!) {
                      repository(owner:$owner, name:$repo) {
                        pullRequest(number:$number) {
                          id
                          autoMergeRequest { enabledAt }
                        }
                      }
                    }`,
                    { owner, repo, number: prNumber }
                  );

                  const prId = q?.repository?.pullRequest?.id;
                  const autoMergeEnabled = !!q?.repository?.pullRequest?.autoMergeRequest;

                  if (prId && autoMergeEnabled) {
                    try {
                      await github.graphql(
                        `mutation($pullRequestId: ID!) {
                          disablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId }) {
                            pullRequest { number }
                          }
                        }`,
                        { pullRequestId: prId }
                      );
                      autoMergeDisabled = true;
                    } catch (mutationErr) {
                      console.warn('‚ö†Ô∏è Unable to disable auto-merge:', mutationErr.message);
                    }
                  }
                } catch (err) {
                  console.warn('‚ö†Ô∏è Unable to query auto-merge status:', err.message);
                }
              }

              // Build and post comment
              const emoji = finalRisk === 'HIGH' ? 'üî¥' : (finalRisk === 'MEDIUM' ? 'üü°' : 'üü¢');
              const statusLine = shouldBlock ? '**Status:** ‚õî BLOCKED' : '**Status:** ‚úÖ CLEAR';

              let out = `${GK_MARKER}\n## üö¶ PR Gatekeeper\n\n`;
              out += `${statusLine}\n`;
              out += `**Risk Level:** ${emoji} ${finalRisk}\n`;
              out += `**Checks:** ${hasFailingChecks ? '‚ùå FAILING' : '‚úÖ PASSING'}\n\n`;
              out += `**Override:** ${isOverride ? '‚úÖ override-gatekeeper present'
                : `‚ùå none (Add label \`${OVERRIDE_LABEL}\` to allow HIGH risk)`}\n\n`;

              if (criticalOverride && criticalMatches.length > 0) {
                out += `### üö® Critical Files Changed\n`;
                criticalMatches.forEach(m => out += `- \`${m.file}\` (${m.reason})\n`);
                out += `\n`;
              }

              if (hasFailingChecks) {
                out += `### ‚ùå Failing Checks\n`;
                for (const name of failing) out += `- ${name}\n`;
                out += `\n`;
              }

              out += `### ‚úÖ Verification Checklist\n`;
              out += `- Confirm no console errors\n`;
              out += `- Smoke test touched flows\n`;
              out += `- pnpm lint / typecheck / build are green\n\n`;

              if (finalRisk === 'HIGH' && !isOverride) {
                out += `### ‚ö†Ô∏è HIGH Risk Override Required\n`;
                out += `Add label \`override-gatekeeper\` to proceed.\n\n`;
              }

              out += autoMergeDisabled
                ? `---\nAuto-merge was disabled.\n`
                : `---\nAuto-merge unchanged.\n`;

              const existing = comments.find(c => (c.body || '').includes(GK_MARKER));
              if (existing) {
                await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body: out });
              } else {
                await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: out });
              }

              console.log('PR Gatekeeper complete');

              if (shouldBlock) {
                console.log('üö´ Gatekeeper is BLOCKING this PR');
                if (finalRisk === 'HIGH' && !isWorkflowOnlyChange && !isOverride) {
                  throw new Error(`Gatekeeper blocked: HIGH risk. Add label ${OVERRIDE_LABEL} to proceed.`);
                } else if (hasFailingChecks) {
                  throw new Error('Gatekeeper blocked: failing checks');
                }
              } else {
                console.log('‚úÖ Gatekeeper passed');
              }

            } catch (e) {
              console.error('Gatekeeper failed:', e);
              throw e;
            }
